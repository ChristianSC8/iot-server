4. Desafíos Encontrados y Soluciones
4.1 Desafío de Seguridad
Problema: La implementación inicial carecía de encriptación end-to-end, exponiendo datos sensibles durante la transmisión entre dispositivos IoT y el backend.
Solución: Se implementó un esquema de seguridad robusto que incluye:

Certificados CA TLS para encriptar comunicaciones MQTT
Autenticación mutua entre dispositivos y broker
Tokens JWT con expiración automática
Validación de integridad de datos mediante checksums

4.2 Escalabilidad del Broker MQTT
Problema: El broker inicial no soportaba múltiples dispositivos concurrentes.
Solución: Migración a Railway con auto-scaling y balanceador de carga, permitiendo manejar hasta 1000+ dispositivos simultáneos.
4.3 Latencia en Tiempo Real
Problema: Retrasos de hasta 5 segundos en la visualización de datos críticos.
Solución: Optimización del pipeline de datos con Rust y implementación de Supabase Realtime, reduciendo la latencia a menos de 200ms.


christian@VivoBook:~/Documents/Programing/Rust/iot-server$ docker run -p 3000:3000   -e DATABASE_HOST=aws-0-us-east-2.pooler.supabase.com   -e DATABASE_USER=postgres.noxekummlwjsekilbjzh   -e DATABASE_PASSWORD=IJ0h8iREGKgM0GM1   -e DATABASE_PORT=6543   -e DATABASE_NAME=postgres   -e PORT=3000   iot-server^C
christian@VivoBook:~/Documents/Programing/Rust/iot-server$ 

christian@VivoBook:~/Documents/Programing/Rust/iot-server$ docker build -t iot-server .


docker run -p 3000:3000 -e DATABASE_HOST=aws-0-us-east-2.pooler.supabase.com -e DATABASE_USER=postgres.sdtlkvmqfsmuzcxodluy -e DATABASE_PASSWORD=123456789 -e DATABASE_PORT=6543 -e DATABASE_NAME=postgres -e PORT=3000 iot-server


docker run -p 3000:3000   -e DATABASE_HOST=aws-0-us-east-2.pooler.supabase.com   -e DATABASE_USER=postgres.sdtlkvmqfsmuzcxodluy   -e DATABASE_PASSWORD=123456789   -e DATABASE_PORT=6543   -e DATABASE_NAME=postgres   -e PORT=3000   iot-server

docker run -p 3000:3000   -e DATABASE_HOST=db.sdtlkvmqfsmuzcxodluy.supabase.co  -e DATABASE_USER=postgres   -e DATABASE_PASSWORD=123456789   -e DATABASE_PORT=5432  -e DATABASE_NAME=postgres   -e PORT=3000   iot-server



docker run -p 3000:3000 -e DATABASE_HOST=aws-0-us-east-2.pooler.supabase.com -e DATABASE_USER=postgres.sdtlkvmqfsmuzcxodluy -e DATABASE_PASSWORD=YlzNdNQtL0Wmc2Ig -e DATABASE_PORT=6543 -e DATABASE_NAME=postgres -e PORT=3000 iot-server


-------------------------------------------------------------------------------------------------------------
database pasword 
YlzNdNQtL0Wmc2Ig

docker build -t iot-server .

docker run -p 3000:3000 -e DATABASE_HOST=aws-0-us-east-2.pooler.supabase.com -e DATABASE_USER=postgres.sdtlkvmqfsmuzcxodluy -e DATABASE_PASSWORD=YlzNdNQtL0Wmc2Ig -e DATABASE_PORT=6543 -e DATABASE_NAME=postgres -e PORT=3000 iot-server

mosquitto_pub \
  -h serveo.net -p 36154 \
  --cafile /home/christian/Documents/Programing/Rust/rust/bin/ca.crt \
  -t "esp32/sensors" \
  -m '{"mq7_co":123,"mq135_no2":45,"dht11_temperature":22.5,"dht11_humidity":55.0,"timestamp":"2025-06-17T12:00:00Z"}' \
  -d

---------
docker build -t rust .

docker run -p 8883:8883 --name broker rust




#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <DHT.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <SPI.h>
#include <time.h>

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET 16
#define OLED_DC    17
#define OLED_CLK   18
#define OLED_MOSI  23

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, OLED_MOSI, OLED_CLK, OLED_DC, OLED_RESET, -1);

#define DHTPIN 15
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

#define BUZZER_PIN 27
#define LED_PIN    26
#define MQ7_PIN    34
#define MQ135_PIN  35

const char* ssid = "tavo";
const char* password = "Salluca15";

const char* mqtt_server = "103.179.45.114";
const int mqtt_port = 8883;
const char* mqtt_topic = "esp32/sensors";

const char* ca_cert = R"(-----BEGIN CERTIFICATE-----
MIIDlzCCAn+gAwIBAgIUKxRcPlgmO7FFfoBFOk82LEXDYFowDQYJKoZIhvcNAQEL
BQAwWzELMAkGA1UEBhMCUEUxDTALBgNVBAgMBExpbWExDTALBgNVBAcMBExpbWEx
DDAKBgNVBAoMA0lPVDEPMA0GA1UECwwGY2xpZW50MQ8wDQYDVQQDDAZicm9rZXIw
HhcNMjUwNjIyMjA1NTQ0WhcNMzAwNjI5MjA1NTQ0WjBbMQswCQYDVQQGEwJQRTEN
MAsGA1UECAwETGltYTENMAsGA1UEBwwETGltYTEMMAoGA1UECgwDSU9UMQ8wDQYD
VQQLDAZjbGllbnQxDzANBgNVBAMMBmJyb2tlcjCCASIwDQYJKoZIhvcNAQEBBQAD
ggEPADCCAQoCggEBAK+iQIyjdTLmXRG6TIa68QyHmDLCse/pjqILLLbznVa1qySj
BVnSiStOvOSK5mRoxpn6JQMsRJKf+RK8O/oV/edXDqb30F4fUB8g+NlxNSN83O1N
S3ohE/TwV58B5HERps+W8/j6iuRycnl0Ui3k5DSHb9vL5XAPiHePiscDfVR+FlMS
3Kya2QSbW1VZCVzU52RCP3HiMKeKQxIU9mkZY71cTrZqH6ozBh9KItT9OQzm0gyS
wl0MQZcw3DwOd7kDOfGccishHVHQ7zibTSWwRUCGuogPfoDcA+HGzYS3dEAalzaa
h2m/wU3SxUG6u++0w1SCJ2e+pB/w1reEKTz6uFcCAwEAAaNTMFEwHQYDVR0OBBYE
FP02sV6cGq9DjbF1WgXLLx6LAZYRMB8GA1UdIwQYMBaAFP02sV6cGq9DjbF1WgXL
Lx6LAZYRMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAIyXwEmS
aSSWEEFv3uYqY78JzSRhpdRlgNlbLYEdjFkrXlWSsizoU4+U989PZl7hs5GfpCAC
vpaj4RGGiqScZjre59UJWXVwM3PdLHOSTdttzTCqO0wFWWHFwf4+ccScxgOKtewV
FSnXmcf5GdUeG61uuZfTemU1ZCnFFz4eHI/4fqCMrrEvMziFvy6Fy9zGqzTwoRk4
DXL81R/MT4MlI8j1W1Hybdn2GGXDiLduythCrezQLGs7HhBqvg60pwUxRbgT05j2
odJy7x44PAZPj0qbO77agNbEXl+QZbImBSv/K0AKYkLabmmHYOoKzLW+9F/QSrwZ
acw3lD4VFc7b2yE=
-----END CERTIFICATE-----)";

WiFiClientSecure secureClient;
PubSubClient client(secureClient);

void setup_wifi() {
  Serial.print("Conectando a ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.print(".");
  }
  Serial.println("\nWiFi conectado");
}

void reconnect_mqtt() {
  while (!client.connected()) {
    Serial.print("Conectando a MQTT...");
    if (client.connect("ESP32Client")) {
      Serial.println("Conectado");
    } else {
      Serial.print("Error: ");
      Serial.print(client.state());
      delay(5000);
    }
  }
}

void mostrarEstadoConexion(bool conectado) {
  display.setCursor(0, SCREEN_HEIGHT - 10); // Última línea
  if (conectado) {
    display.print("MQTT: Conectado");
  } else {
    display.print("MQTT: Desconectado");
  }
}

void setup() {
  Serial.begin(115200);
  dht.begin();

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println("Fallo OLED");
    while (true);
  }

  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.println("Iniciando...");
  display.display();

  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);
  digitalWrite(LED_PIN, LOW);

  setup_wifi();

  configTime(-5 * 3600, 0, "pool.ntp.org", "time.nist.gov");
  struct tm timeinfo;
  while (!getLocalTime(&timeinfo)) {
    delay(500);
  }

  secureClient.setCACert(ca_cert);
  client.setServer(mqtt_server, mqtt_port);

  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("Sistema listo");
  display.display();
  delay(2000);
}

String obtenerFechaHora() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    return "Error";
  }
  char buffer[30];
  strftime(buffer, sizeof(buffer), "%Y-%m-%dT%H:%M:%SZ", &timeinfo);
  return String(buffer);
}

void loop() {
  if (!client.connected()) {
    reconnect_mqtt();
  }
  client.loop();

  float temp = dht.readTemperature();
  float hum = dht.readHumidity();

  int mq7Value = analogRead(MQ7_PIN);
  int mq135Value = analogRead(MQ135_PIN);

  float co_ppm = mq7Value * 0.2;
  float nh3_ppm = mq135Value * 0.1;
  float co2_ppm = mq135Value * 0.15;

  String timestamp = obtenerFechaHora();

  static int pantalla = 0;
  pantalla = (pantalla + 1) % 2;

  display.clearDisplay();
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.println("  ManisDev's");
  display.drawLine(0, 10, SCREEN_WIDTH, 10, SSD1306_WHITE);
  int y = 12;

  if (pantalla == 0) {
    display.setCursor(0, y); display.print("Temp: "); display.print(temp); display.println(" C"); y += 10;
    display.setCursor(0, y); display.print("Hum: "); display.print(hum); display.println(" %"); y += 10;
  } else {
    display.setCursor(0, y); display.print("CO: "); display.print(co_ppm); display.println(" ppm"); y += 10;
    display.setCursor(0, y); display.print("NH3: "); display.print(nh3_ppm); display.println(" ppm"); y += 10;
    display.setCursor(0, y); display.print("CO2: "); display.print(co2_ppm); display.println(" ppm"); y += 10;
  }

  mostrarEstadoConexion(client.connected());  // Mostrar estado MQTT
  display.display();

  if (co_ppm > 300 || nh3_ppm > 300) {
    tone(BUZZER_PIN, 1000);
    digitalWrite(LED_PIN, HIGH);
  } else {
    noTone(BUZZER_PIN);
    digitalWrite(LED_PIN, LOW);
  }

  String payload = "{";
  payload += "\"mq7_co\":" + String(mq7Value) + ",";
  payload += "\"mq135_no2\":" + String(mq135Value) + ",";
  payload += "\"dht11_temperature\":" + String(temp) + ",";
  payload += "\"dht11_humidity\":" + String(hum) + ",";
  payload += "\"timestamp\":\"" + timestamp + "\"}";

  if (client.publish(mqtt_topic, payload.c_str())) {
    Serial.println("Datos enviados a MQTT");
  } else {
    Serial.println("Error al enviar a MQTT");
  }

  delay(5000);
}


mosquitto_sub -h 103.179.45.114 -p 8883 --cafile /home/christian/Pictures/IOT-PROJECT/iot-broker/bin/ca.crt -t "esp32/sensors" -d





# Multi-stage build para optimizar el tamaño final
FROM rust:1.87-bookworm AS builder

# Instalar dependencias de sistema necesarias para la compilación
RUN apt-get update && \
    apt-get install -y \
    pkg-config \
    libssl-dev \
    ca-certificates \
    cmake \
    build-essential && \
    rm -rf /var/lib/apt/lists/*

WORKDIR /usr/src/app

# Copiar archivos de configuración de Cargo primero para aprovechar cache de Docker
COPY Cargo.toml Cargo.lock ./

# Crear directorio src con main.rs dummy para compilar dependencias
RUN mkdir src && \
    echo "fn main() {}" > src/main.rs && \
    echo "" > src/lib.rs

# Compilar solo las dependencias (optimización de cache)
RUN cargo build --release && \
    rm -rf src/

# Copiar el código fuente real
COPY src ./src
COPY bin ./bin

# Recompilar solo el código de la aplicación
RUN touch src/main.rs && \
    cargo build --release

# Etapa final - imagen mínima
FROM debian:bookworm-slim

# Instalar dependencias de runtime
RUN apt-get update && \
    apt-get install -y \
    libssl3 \
    ca-certificates \
    curl && \
    rm -rf /var/lib/apt/lists/* && \
    apt-get clean

# Crear usuario no-root para seguridad
RUN groupadd -r iotuser && \
    useradd -r -g iotuser iotuser

# Crear directorios necesarios
RUN mkdir -p /app/bin /app/logs && \
    chown -R iotuser:iotuser /app

# Copiar binario compilado
COPY --from=builder /usr/src/app/target/release/iot-server /app/iot-server

# Copiar certificado TLS
COPY --from=builder /usr/src/app/bin/ca.crt /app/bin/ca.crt

# Cambiar ownership de los archivos
RUN chown -R iotuser:iotuser /app && \
    chmod +x /app/iot-server

# Configuar usuario
USER iotuser

# Establecer directorio de trabajo
WORKDIR /app

# Variables de entorno por defecto
ENV RUST_LOG=info
ENV PORT=4848

# Exponer puerto (ajustado al puerto real de la aplicación)
EXPOSE 4848

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:${PORT}/health || exit 1

# Comando por defecto
CMD ["./iot-server"]

version: '3.8'

services:
  # Base de datos PostgreSQL
  postgres:
    image: postgres:15-alpine
    container_name: iot_postgres
    environment:
      POSTGRES_DB: ${DATABASE_NAME:-iot_sensors}
      POSTGRES_USER: ${DATABASE_USER:-iot_user}
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD:-iot_password}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    ports:
      - "${DATABASE_PORT:-5432}:5432"
    networks:
      - iot_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DATABASE_USER:-iot_user} -d ${DATABASE_NAME:-iot_sensors}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Aplicación IoT Server
  iot-server:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: iot_server
    environment:
      DATABASE_HOST: postgres
      DATABASE_PORT: 5432
      DATABASE_NAME: ${DATABASE_NAME:-iot_sensors}
      DATABASE_USER: ${DATABASE_USER:-iot_user}
      DATABASE_PASSWORD: ${DATABASE_PASSWORD:-iot_password}
      PORT: ${PORT:-4848}
      MQTT_HOST: ${MQTT_HOST:-103.179.45.114}
      MQTT_PORT: ${MQTT_PORT:-8883}
      MQTT_CLIENT_ID: ${MQTT_CLIENT_ID:-rust-mqtt-client}
      MQTT_TOPIC: ${MQTT_TOPIC:-esp32/sensors}
      RUST_LOG: ${RUST_LOG:-info}
    ports:
      - "${PORT:-4848}:4848"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - iot_network
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4848/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # pgAdmin para administración de base de datos (opcional)
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: iot_pgadmin
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_EMAIL:-admin@iot.local}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PASSWORD:-admin123}
      PGADMIN_CONFIG_SERVER_MODE: 'False'
    ports:
      - "${PGADMIN_PORT:-8080}:80"
    depends_on:
      - postgres
    networks:
      - iot_network
    volumes:
      - pgadmin_data:/var/lib/pgadmin
    restart: unless-stopped
    profiles:
      - admin

  # Nginx reverse proxy (opcional para producción)
  nginx:
    image: nginx:alpine
    container_name: iot_nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - iot-server
    networks:
      - iot_network
    restart: unless-stopped
    profiles:
      - production

volumes:
  postgres_data:
    driver: local
  pgadmin_data:
    driver: local

networks:
  iot_network:
    driver: bridge




# Database Configuration
DATABASE_HOST=localhost
DATABASE_PORT=5432
DATABASE_NAME=iot_sensors
DATABASE_USER=iot_user
DATABASE_PASSWORD=iot_password

# API Configuration
PORT=4848

# MQTT Configuration
MQTT_HOST=103.179.45.114
MQTT_PORT=8883
MQTT_CLIENT_ID=rust-mqtt-client
MQTT_TOPIC=esp32/sensors

# Logging
RUST_LOG=info

# pgAdmin (opcional)
PGADMIN_EMAIL=admin@iot.local
PGADMIN_PASSWORD=admin123
PGADMIN_PORT=8080



# Build
docker build -t iot-server .

# Run
docker run -p 4848:4848 --env-file .env iot-server