4. Desafíos Encontrados y Soluciones
4.1 Desafío de Seguridad
Problema: La implementación inicial carecía de encriptación end-to-end, exponiendo datos sensibles durante la transmisión entre dispositivos IoT y el backend.
Solución: Se implementó un esquema de seguridad robusto que incluye:

Certificados CA TLS para encriptar comunicaciones MQTT
Autenticación mutua entre dispositivos y broker
Tokens JWT con expiración automática
Validación de integridad de datos mediante checksums

4.2 Escalabilidad del Broker MQTT
Problema: El broker inicial no soportaba múltiples dispositivos concurrentes.
Solución: Migración a Railway con auto-scaling y balanceador de carga, permitiendo manejar hasta 1000+ dispositivos simultáneos.
4.3 Latencia en Tiempo Real
Problema: Retrasos de hasta 5 segundos en la visualización de datos críticos.
Solución: Optimización del pipeline de datos con Rust y implementación de Supabase Realtime, reduciendo la latencia a menos de 200ms.


christian@VivoBook:~/Documents/Programing/Rust/iot-server$ docker run -p 3000:3000   -e DATABASE_HOST=aws-0-us-east-2.pooler.supabase.com   -e DATABASE_USER=postgres.noxekummlwjsekilbjzh   -e DATABASE_PASSWORD=IJ0h8iREGKgM0GM1   -e DATABASE_PORT=6543   -e DATABASE_NAME=postgres   -e PORT=3000   iot-server^C
christian@VivoBook:~/Documents/Programing/Rust/iot-server$ 

christian@VivoBook:~/Documents/Programing/Rust/iot-server$ docker build -t iot-server .


docker run -p 3000:3000 -e DATABASE_HOST=aws-0-us-east-2.pooler.supabase.com -e DATABASE_USER=postgres.sdtlkvmqfsmuzcxodluy -e DATABASE_PASSWORD=123456789 -e DATABASE_PORT=6543 -e DATABASE_NAME=postgres -e PORT=3000 iot-server


docker run -p 3000:3000   -e DATABASE_HOST=aws-0-us-east-2.pooler.supabase.com   -e DATABASE_USER=postgres.sdtlkvmqfsmuzcxodluy   -e DATABASE_PASSWORD=123456789   -e DATABASE_PORT=6543   -e DATABASE_NAME=postgres   -e PORT=3000   iot-server

docker run -p 3000:3000   -e DATABASE_HOST=db.sdtlkvmqfsmuzcxodluy.supabase.co  -e DATABASE_USER=postgres   -e DATABASE_PASSWORD=123456789   -e DATABASE_PORT=5432  -e DATABASE_NAME=postgres   -e PORT=3000   iot-server



docker run -p 3000:3000 -e DATABASE_HOST=aws-0-us-east-2.pooler.supabase.com -e DATABASE_USER=postgres.sdtlkvmqfsmuzcxodluy -e DATABASE_PASSWORD=YlzNdNQtL0Wmc2Ig -e DATABASE_PORT=6543 -e DATABASE_NAME=postgres -e PORT=3000 iot-server


-------------------------------------------------------------------------------------------------------------
database pasword 
YlzNdNQtL0Wmc2Ig

docker build -t iot-server .

docker run -p 3000:3000 -e DATABASE_HOST=aws-0-us-east-2.pooler.supabase.com -e DATABASE_USER=postgres.sdtlkvmqfsmuzcxodluy -e DATABASE_PASSWORD=YlzNdNQtL0Wmc2Ig -e DATABASE_PORT=6543 -e DATABASE_NAME=postgres -e PORT=3000 iot-server

mosquitto_pub \
  -h serveo.net -p 36154 \
  --cafile /home/christian/Documents/Programing/Rust/rust/bin/ca.crt \
  -t "esp32/sensors" \
  -m '{"mq7_co":123,"mq135_no2":45,"dht11_temperature":22.5,"dht11_humidity":55.0,"timestamp":"2025-06-17T12:00:00Z"}' \
  -d

---------
docker build -t rust .

docker run -p 8883:8883 --name broker rust




#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <DHT.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <SPI.h>
#include <time.h>

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET 16
#define OLED_DC    17
#define OLED_CLK   18
#define OLED_MOSI  23

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, OLED_MOSI, OLED_CLK, OLED_DC, OLED_RESET, -1);

#define DHTPIN 15
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

#define BUZZER_PIN 27
#define LED_PIN    26
#define MQ7_PIN    34
#define MQ135_PIN  35

const char* ssid = "tavo";
const char* password = "Salluca15";

const char* mqtt_server = "103.179.45.114";
const int mqtt_port = 8883;
const char* mqtt_topic = "esp32/sensors";

const char* ca_cert = R"(-----BEGIN CERTIFICATE-----
MIIDlzCCAn+gAwIBAgIUKxRcPlgmO7FFfoBFOk82LEXDYFowDQYJKoZIhvcNAQEL
BQAwWzELMAkGA1UEBhMCUEUxDTALBgNVBAgMBExpbWExDTALBgNVBAcMBExpbWEx
DDAKBgNVBAoMA0lPVDEPMA0GA1UECwwGY2xpZW50MQ8wDQYDVQQDDAZicm9rZXIw
HhcNMjUwNjIyMjA1NTQ0WhcNMzAwNjI5MjA1NTQ0WjBbMQswCQYDVQQGEwJQRTEN
MAsGA1UECAwETGltYTENMAsGA1UEBwwETGltYTEMMAoGA1UECgwDSU9UMQ8wDQYD
VQQLDAZjbGllbnQxDzANBgNVBAMMBmJyb2tlcjCCASIwDQYJKoZIhvcNAQEBBQAD
ggEPADCCAQoCggEBAK+iQIyjdTLmXRG6TIa68QyHmDLCse/pjqILLLbznVa1qySj
BVnSiStOvOSK5mRoxpn6JQMsRJKf+RK8O/oV/edXDqb30F4fUB8g+NlxNSN83O1N
S3ohE/TwV58B5HERps+W8/j6iuRycnl0Ui3k5DSHb9vL5XAPiHePiscDfVR+FlMS
3Kya2QSbW1VZCVzU52RCP3HiMKeKQxIU9mkZY71cTrZqH6ozBh9KItT9OQzm0gyS
wl0MQZcw3DwOd7kDOfGccishHVHQ7zibTSWwRUCGuogPfoDcA+HGzYS3dEAalzaa
h2m/wU3SxUG6u++0w1SCJ2e+pB/w1reEKTz6uFcCAwEAAaNTMFEwHQYDVR0OBBYE
FP02sV6cGq9DjbF1WgXLLx6LAZYRMB8GA1UdIwQYMBaAFP02sV6cGq9DjbF1WgXL
Lx6LAZYRMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAIyXwEmS
aSSWEEFv3uYqY78JzSRhpdRlgNlbLYEdjFkrXlWSsizoU4+U989PZl7hs5GfpCAC
vpaj4RGGiqScZjre59UJWXVwM3PdLHOSTdttzTCqO0wFWWHFwf4+ccScxgOKtewV
FSnXmcf5GdUeG61uuZfTemU1ZCnFFz4eHI/4fqCMrrEvMziFvy6Fy9zGqzTwoRk4
DXL81R/MT4MlI8j1W1Hybdn2GGXDiLduythCrezQLGs7HhBqvg60pwUxRbgT05j2
odJy7x44PAZPj0qbO77agNbEXl+QZbImBSv/K0AKYkLabmmHYOoKzLW+9F/QSrwZ
acw3lD4VFc7b2yE=
-----END CERTIFICATE-----)";

WiFiClientSecure secureClient;
PubSubClient client(secureClient);

void setup_wifi() {
  Serial.print("Conectando a ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.print(".");
  }
  Serial.println("\nWiFi conectado");
}

void reconnect_mqtt() {
  while (!client.connected()) {
    Serial.print("Conectando a MQTT...");
    if (client.connect("ESP32Client")) {
      Serial.println("Conectado");
    } else {
      Serial.print("Error: ");
      Serial.print(client.state());
      delay(5000);
    }
  }
}

void mostrarEstadoConexion(bool conectado) {
  display.setCursor(0, SCREEN_HEIGHT - 10); // Última línea
  if (conectado) {
    display.print("MQTT: Conectado");
  } else {
    display.print("MQTT: Desconectado");
  }
}

void setup() {
  Serial.begin(115200);
  dht.begin();

  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println("Fallo OLED");
    while (true);
  }

  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.println("Iniciando...");
  display.display();

  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);
  digitalWrite(LED_PIN, LOW);

  setup_wifi();

  configTime(-5 * 3600, 0, "pool.ntp.org", "time.nist.gov");
  struct tm timeinfo;
  while (!getLocalTime(&timeinfo)) {
    delay(500);
  }

  secureClient.setCACert(ca_cert);
  client.setServer(mqtt_server, mqtt_port);

  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("Sistema listo");
  display.display();
  delay(2000);
}

String obtenerFechaHora() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    return "Error";
  }
  char buffer[30];
  strftime(buffer, sizeof(buffer), "%Y-%m-%dT%H:%M:%SZ", &timeinfo);
  return String(buffer);
}

void loop() {
  if (!client.connected()) {
    reconnect_mqtt();
  }
  client.loop();

  float temp = dht.readTemperature();
  float hum = dht.readHumidity();

  int mq7Value = analogRead(MQ7_PIN);
  int mq135Value = analogRead(MQ135_PIN);

  float co_ppm = mq7Value * 0.2;
  float nh3_ppm = mq135Value * 0.1;
  float co2_ppm = mq135Value * 0.15;

  String timestamp = obtenerFechaHora();

  static int pantalla = 0;
  pantalla = (pantalla + 1) % 2;

  display.clearDisplay();
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.println("  ManisDev's");
  display.drawLine(0, 10, SCREEN_WIDTH, 10, SSD1306_WHITE);
  int y = 12;

  if (pantalla == 0) {
    display.setCursor(0, y); display.print("Temp: "); display.print(temp); display.println(" C"); y += 10;
    display.setCursor(0, y); display.print("Hum: "); display.print(hum); display.println(" %"); y += 10;
  } else {
    display.setCursor(0, y); display.print("CO: "); display.print(co_ppm); display.println(" ppm"); y += 10;
    display.setCursor(0, y); display.print("NH3: "); display.print(nh3_ppm); display.println(" ppm"); y += 10;
    display.setCursor(0, y); display.print("CO2: "); display.print(co2_ppm); display.println(" ppm"); y += 10;
  }

  mostrarEstadoConexion(client.connected());  // Mostrar estado MQTT
  display.display();

  if (co_ppm > 300 || nh3_ppm > 300) {
    tone(BUZZER_PIN, 1000);
    digitalWrite(LED_PIN, HIGH);
  } else {
    noTone(BUZZER_PIN);
    digitalWrite(LED_PIN, LOW);
  }

  String payload = "{";
  payload += "\"mq7_co\":" + String(mq7Value) + ",";
  payload += "\"mq135_no2\":" + String(mq135Value) + ",";
  payload += "\"dht11_temperature\":" + String(temp) + ",";
  payload += "\"dht11_humidity\":" + String(hum) + ",";
  payload += "\"timestamp\":\"" + timestamp + "\"}";

  if (client.publish(mqtt_topic, payload.c_str())) {
    Serial.println("Datos enviados a MQTT");
  } else {
    Serial.println("Error al enviar a MQTT");
  }

  delay(5000);
}


mosquitto_sub -h 103.179.45.114 -p 8883 --cafile /home/christian/Pictures/IOT-PROJECT/iot-broker/bin/ca.crt -t "esp32/sensors" -d